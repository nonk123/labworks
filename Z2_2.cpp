/*
 * №2. Сканирование прямоугольной матрицы.
 *
 * Дана матрица размером MxN. Необходимо сформировать из неё одномерный массив
 * посредством сканирования её элементов двумя способами:
 *   1. Первый столбик сканируется сверху вниз. Второй - снизу вверх. Третий -
 *      как первый. И т.д.
 *   2. Первая строчка сканируется слева направо. Вторая - справа налево.
 *      третья - как первая. И т.д.
 */

#include "common.hpp"

/*
 * Функция освобождения двумерного динамического массива (матрицы).
 *
 * Входные параметры:
 *   A - массив строк некоторой матрицы;
 *   M - число строк в ней.
 *
 * Возвращаемое значение - код завершения:
 *   0 - успешное выполнение функции;
 *   1 - передан параметр M меньше нуля.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 13.04.21
 */
int
free_matrix (int** A, int M)
{
  int i;

  if (A == NULL)
    return 0;

  if (M < 0)
    return 1;

  for (i = 0; i < M; i++)
    {
      if (A[i] != NULL)
        {
          delete[] A[i];
          A[i] = NULL;
        }
    }

  delete[] A;
  A = NULL;

  return 0;
}

/*
 * Функция сканирования матрицы по столбикам.
 *
 * Входные параметры:
 *   R - массив, являющийся результатом сканирования матрицы;
 *   A - матрица, которую необходимо просканировать;
 *   M, N - количество строк и столбцов в ней соответственно.
 *
 * Возвращаемое значение - код завершения:
 *   0 - успешное выполнение функции;
 *   1 - по указателю R не захвачена память;
 *   2 - по указателю A не захвачена память;
 *   3 - матрица на содержит элементов.
 *
 * Примечание:
 *   Захваченной памяти по указателю R должно хватить на M * N элементов.
 *
 * Алгоритм:
 *   Направление сканирования меняется после каждого столбика. Для этого
 *   реализованы два различных цикла.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 13.04.21
 */
int
scan_cols (int* R, int** A, int M, int N)
{
  int i, j, k = 0;

  if (R == NULL)
    return 1;

  if (A == NULL)
    return 2;

  if (M <= 0 || N <= 0)
    return 3;

  for (j = 0; j < N; j++)
    {
      if (j % 2) /* индексы 1, 3, 5, ... */
        {
          for (i = M - 1; i >= 0; i--, k++)
            R[k] = A[i][j];
        }
      else /* индексы 0, 2, 4, ... */
        {
          for (i = 0; i < M; i++, k++)
            R[k] = A[i][j];
        }
    }

  return 0;
}

/*
 * Функция построчного сканирования матрицы.
 *
 * Входные параметры:
 *   R - массив, являющийся результатом сканирования матрицы;
 *   A - матрица, которую необходимо просканировать;
 *   M, N - количество строк и столбцов в ней соответственно.
 *
 * Возвращаемое значение - код завершения:
 *   0 - успешное выполнение функции;
 *   1 - по указателю R не захвачена память;
 *   2 - по указателю A не захвачена память;
 *   3 - матрица на содержит элементов.
 *
 * Примечание:
 *   Захваченной памяти по указателю R должно хватить на M * N элементов.
 *
 * Алгоритм:
 *   Направление сканирования меняется после каждой строчки. Для этого
 *   реализованы два различных цикла.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 13.04.21
 */
int
scan_rows (int* R, int** A, int M, int N)
{
  int i, j, k = 0;

  if (R == NULL)
    return 1;

  if (A == NULL)
    return 2;

  if (M <= 0 || N <= 0)
    return 3;

  for (i = 0; i < M; i++)
    {
      if (i % 2) /* индексы 1, 3, 5, ... */
        {
          for (j = N - 1; j >= 0; j--, k++)
            R[k] = A[i][j];
        }
      else /* индексы 0, 2, 4, ... */
        {
          for (j = 0; j < N; j++, k++)
            R[k] = A[i][j];
        }
    }

  return 0;
}

int
main ()
{
  int **A = NULL, *R = NULL;
  int M, N, i, j;

  /* Правильный вывод кириллицы. */
  fix_locale ();

  /* Ввод размера матрицы. */

  do
    {
      cout << "M = ";
      cin >> M;
    }
  while (M < 2 || M > 15);

  do
    {
      cout << "N = ";
      cin >> N;
    }
  while (N < 2 || N > 15);

  /* Захват памяти под результирующий массив. */
  R = new int[M * N];

  if (R == NULL)
    {
      cout << "Ошибка захвата памяти" << endl;
      getch ();
      return 1;
    }

  /* Захват памяти под матрицу. */
  A = new int*[M];

  if (A == NULL)
    {
      if (R != NULL)
        {
          delete[] R;
          R = NULL;
        }

      cout << "Ошибка захвата памяти" << endl;
      getch ();
      return 1;
    }

  for (i = 0; i < M; i++)
    {
      A[i] = new int[N];

      if (A[i] == NULL)
        {
          free_matrix (A, i);

          if (R != NULL)
            {
              delete[] R;
              R = NULL;
            }

          cout << "Ошибка захвата памяти" << endl;
          getch ();
          return 1;
        }

    }

  cout << endl << "Матрица A: " << endl;

  randomize ();

  /* Заполнение матрицы случайными числами. */
  for (i = 0; i < M; i++)
    {
      for (j = 0; j < N; j++)
        {
          A[i][j] = random (21);
          cout << setw (3) << A[i][j];
        }

      cout << endl;
    }

  /* Сканирование по столбикам. */
  switch (scan_cols (R, A, M, N))
    {
    case 0:
      cout << endl << "Результат сканирования матрицы по столбикам:" << endl;

      for (i = 0; i < M * N; i++)
        cout << R[i] << " ";

      cout << endl;
      break;
    case 1:
    case 2:
      cout << endl << "Ошибка захвата памяти" << endl;
      break;
    case 3:
      cout << endl << "Матрица пуста" << endl;
      break;
    }

  /* Построчное сканирование. */
  switch (scan_rows (R, A, M, N))
    {
    case 0:
      cout << endl << "Результат построчного сканирования матрицы:" << endl;

      for (i = 0; i < M * N; i++)
        cout << R[i] << " ";

      break;
    case 1:
    case 2:
      cout << endl << "Ошибка захвата памяти" << endl;
      break;
    case 3:
      cout << endl << "Матрица пуста" << endl;
      break;
    }

  /* Освобождение ранее захваченной памяти. */

  free_matrix (A, M);

  if (R != NULL)
    {
      delete[] R;
      R = NULL;
    }

  getch ();
  return 0;
}
