#+TITLE: "Массивы в языке программирования Си"

#+INCLUDE: ../title.org

* Аннотация

В лабораторной работе рассматривается применение массивов для решения
задач на языке Си. Массивы используются для группирования данных одного
типа в блок с общим названием.

{{{pagebr}}}

#+TOC: headlines 2

* Теоретическая часть

Сведения были взяты из материлов лекции №4.

** Понятие массива

Массив - это непрерывная совокупность байт, размещаемая в оперативной
памяти компьютера относительно некоторого стартового адреса.

Массивы появились в языках программирования как параллель математическим
понятиям матрица и вектор.

Массивы позволяют хранить множество значений одного типа (=int=, =float=
и т.д.) под одним названием переменной.

Получить доступ к элементу массива можно, зная его индекс. Размерность
массива - это количество индексов, по которым осуществляется доступ к
элементу. Размер (или длина) массива - максимальное количество
элементов, которые можно разместить в массиве.

Массивы делятся на статические (размер известен при компиляции
программы) и динамические (размер задаётся в процессе выполнения
программы).

** Одномерный массив

Доступ к элементам одномерного массива осуществляется по одному индексу.

Перед использованием массив должен быть объявлен. Осуществляется это
так:

#+BEGIN_SRC cpp
   short int age[3];
//     |      |  |
//     |      |  *- длина массива в квадратных скобках
//     |      *- название массива
//     *- тип данных массива
#+END_SRC

Длина массива задаётся числовым литералом или числовой константой. Длина
массива должна быть известна на стадии компиляции программы и не
изменяется в процессе её выполнения.

Члены массива называются элементами. Изобразим массив выше, заполнив его
некоторыми значениями. Адресация увеличивается сверху вниз:

#+BEGIN_SRC ditaa :results silent :file tmp/1d.png
+-----+
| 49  |
|--=--| age[0]
|     |
+-----+ 
| 17  |
|--=--| age[1]
|     |
+-----+
| 24  |
|--=--| age[2]
|     |
+-----+
#+END_SRC

#+RESULTS:
#+ATTR_ODT: :anchor as-char
[[file:tmp/1d.png]]

Из рисунка видно, что в массиве находятся три элемента - 49, 17
и 24. Каждый из них, имея тип =short int=, занимает два байта.
Индексация массивов начинается с нуля, поэтому последний элемент имеет
индекс на единицу меньше длины массива.

Проверки на выход за пределы массива в языке Си нет. Считывание значения
из ячейки за пределами массива скажется только на выполнении программы,
но запись может привести к краху всей операционной системы.

Заранее проинициализировать значения элементов массива можно с помощью
фигурных скобок. В этом случае указывать длину массива необязательно:

#+BEGIN_SRC cpp
   short int age[] = {49, 17, 24};
//              |    |
//              |    *- элементы массива указываются в
//              |       фигурных скобках и разделяются запятыми
//              *- длина массива может быть опущена
#+END_SRC

Если при инициализации массива всё же указать длину, то могут быть три
исхода:

1. Указанная длина соответствует количеству проинициализированных
   элементов, и программа успешно компилируется.
2. Указанная длина больше количества проинициализированных элементов. В
   этом случае элементы сверх проинициализированных получат значение 0.
3. При указанной длине меньше количества проинициализированных элементов
   возникнет ошибка компиляции.

Для задания длины массива можно использовать константу:

#+BEGIN_SRC cpp
  const int SIZE = 3;
  short int age[SIZE];

  for (int i = 0; i < SIZE; i++)
      age[i] = 1 + rand() % 100;
#+END_SRC

Это очень полезно в случае, когда размер массива может измениться во
время написания программы и используется в ней несколько раз.  Ручная
замена числового литерала (в данном случае - 3) не всегда удобна и может
привести к ошибкам.

** Многомерные массивы

Массивы могут иметь большую размерность. У одномерного массива она равна
единице; у двумерного - двойке; у трёхмерного - тройке и т.д.

Двумерный массив по сути является массивом массивов, и для доступа к его
элементам используются два индекса. Каждый индекс указывается в
отдельных квадратных скобках. Писать =grid[2,0]= нельзя.

Многомерные массивы инициализируются посредством инициализации
подмассивов в массиве. Например:

#+BEGIN_SRC cpp
  int grid[][] = {
      {1, 1, 1, 1, 1},
      {1, 0, 0, 0, 1},
      {1, 0, 2, 0, 1},
      {1, 0, 0, 0, 1},
      {1, 1, 1, 1, 1},
  };

  cout << grid[2][0] << endl;
#+END_SRC

Данный участок кода выведет число 1. =grid[2][0]= - первый элемент
третьего сверху массива.

Трёхмерный массив - это массив массивов, которые состоят из
массивов. Доступ к его элементам осуществляется с помощью трёх индексов.
По такой же логике можно задать массив любой размерности больше единицы.

** Границы массива

В языке Си нет проверки границ массива. Как уже писалось выше, запись за
пределы массива может привести к краху операционной системы.

Программисту следует проверять индексы самому. Например, в цикле ввода
чисел для заполнения массива:

#+BEGIN_SRC cpp
  if (n >= SIZE) {
      cout << "Массив полон!" << endl;
      break;
  }
#+END_SRC

=n= - количество введённых элементов. =SIZE= - размер массива. Если
введено столько же или более элементов, чем может содержать массив, то
мы оповещаем об этом пользователя и останавливаем цикл.

* Практическая часть

Автор программ - {{{author}}}.

Все программные модули были протестированы в следующей среде:

- Операционная система: {{{kernel}}}.
- ОЗУ: {{{ram}}}.
- ЦП: {{{cpu}}}.
- Видеокарта: {{{gpu}}}.
- Компилятор: {{{compiler}}}.
- {{{misc}}}.

** Пример заполнения одномерного массива

Следующий код заполняет массив =n= десятью случайными числами от 0 до 9
и выводит их на экран через два пробела:

#+INCLUDE: Z4_1.cpp src cpp

Функция =rand= из заголовка =stdlib.h= генерирует случайное число, а
операция остатка от деления ограничивает это значение.

*** Блок-схема

#+BEGIN_SRC plantuml :results silent :file tmp/Z4_1.png
start
:Объявление n;
:int i = 0;
repeat
  :Генерация числа
  от 0 до 9;
  :Присвоение его n[i];
  :Вывод числа через
  два пробела;
repeat while (++i < 10?) is (да)
:Вывод переноса
строки;
stop
#+END_SRC

#+RESULTS:
#+ATTR_ODT: :anchor as-char
[[file:tmp/Z4_1.png]]

*** Пример работы программы

Массив был заполнен случайными числами:

#+ATTR_ODT: :anchor as-char
[[./img/Z4_1_1.png]]

#+ATTR_ODT: :anchor as-char
[[./img/Z4_1_2.png]]

#+ATTR_ODT: :anchor as-char
[[./img/Z4_1_3.png]]

** Количество дней с начала года и до введённой даты

#+INCLUDE: Z4_2.cpp src cpp

Программа не работает для високосных лет.

*** Блок-схема

#+BEGIN_SRC plantuml :results silent :file tmp/Z4_2.png
start
:Ввод месяца и дня;
:Число дней = введённый день;
:i = 1;
repeat
  :К числу дней прибавить
  число дней в месяце i;
repeat while (++i < введённый месяц?) is (да)
:Вывод числа дней;
stop
#+END_SRC

#+RESULTS:
#+ATTR_ODT: :anchor as-char
[[file:tmp/Z4_2.png]]

*** Пример работы программы

Дата из лекции - 3/11:

#+ATTR_ODT: :anchor as-char
[[./img/Z4_2_lecture.png]]

Реальный пример: количество дней от 1 января до 25 декабря. На выходе
должно получиться значение 359 (365 дней в году минус 6 дней от 31
декабря).

#+ATTR_ODT: :anchor as-char
[[./img/Z4_2_mine.png]]

** Среднее арифметическое элементов массива

Следующая программа выводит средний дневной объём продаж за шесть дней:

#+INCLUDE: Z4_3.cpp src cpp

В вычислениях используется формула среднего арифметического:

\[A_{avg} = \frac{\sum_{i = 1}^n A_i}{n}\]

*** Блок-схема

#+BEGIN_SRC plantuml :results silent :file tmp/Z4_3.png
start
:Ввод шести значений
в массив;
:Нахождение их суммы;
:Вычисление среднего
арифметического;
:Вывод этого значения;
stop
#+END_SRC

#+RESULTS:
#+ATTR_ODT: :anchor as-char
[[file:tmp/Z4_3.png]]

*** Пример работы программы

Входные данные из лекции:

#+ATTR_ODT: :anchor as-char
[[./img/Z4_3_lecture.png]]

Одинаковый объём продаж каждый день:

#+ATTR_ODT: :anchor as-char
[[./img/Z4_3_mine.png]]

Проверка:

\[\frac{100 + 100 + 100 + 100 + 100 + 100}{6} = \frac{600}{6} = 100\]

** Показ графика продаж

Программа вводит данные о продажах с клавиатуры и выводит их в виде
таблицы.

#+INCLUDE: Z4_4.cpp src cpp

*** Блок-схема

#+BEGIN_SRC plantuml :results silent :file tmp/Z4_4.png
start
:Ввод табличных значений;
:Вывод шапки;
:district = 0;
repeat
  :Вывод номера отдела;
  :month = 0;
  repeat
    :Вывод ячейки с
    форматированием;
  repeat while (++month < число месяцев?) is (да)
  :Перенос строки;
repeat while (++district < число отделов?) is (да)
stop
#+END_SRC

#+RESULTS:
#+ATTR_ODT: :anchor as-char
[[file:tmp/Z4_4.png]]

*** Пример работы программы

Входные данные из лекции:

#+ATTR_ODT: :anchor as-char
[[./img/Z4_4_lecture.png]]

Произвольные данные - числа от 1 до 12:

#+ATTR_ODT: :anchor as-char
[[./img/Z4_4_mine.png]]

** Показ графика продаж по данным массива

Данный код аналогичен коду предыдущей программы, но вместо ввода с
клавиатуры массив =sales= инициализируется на стадии компиляции.

#+INCLUDE: Z4_5.cpp src cpp

*** Блок-схема

# TODO: prevent copypasta?
#+BEGIN_SRC plantuml :results silent :file tmp/Z4_5.png
start
:Вывод шапки;
:district = 0;
repeat
  :Вывод номера отдела;
  :month = 0;
  repeat
    :Вывод ячейки с
    форматированием;
  repeat while (++month < число месяцев?) is (да)
  :Перенос строки;
repeat while (++district < число отделов?) is (да)
stop
#+END_SRC

#+RESULTS:
#+ATTR_ODT: :anchor as-char
[[file:tmp/Z4_5.png]]

*** Пример работы программы

Вывод можно сравнить с ручным форматированием при инициализации массива.

#+ATTR_ODT: :anchor as-char
[[./img/Z4_5.png]]

* Выводы

В результате работы с примерами из материалов лекции я научился
использовать одномерные и многомерные массивы. Их применение невероятно
широко и позволяет упростить написание программ.
