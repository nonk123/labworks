/*
 * №2. Нахождение элементов массива, наиболее близкого и наиболее далёкого по
 *     значению от суммы элементов этого массива.
 *
 * Задан целочисленный массив. Необходимо найти значения и индексы его
 * элементов, наиболее близкого и наиболее далёкого от суммы элементов этого
 * массива. Массив объявить динамически. Искомые по условию элементы и сумму
 * найти посредством функций.
 */

#include "common.hpp"

/*
 * Функция нахождения суммы элементов массива.
 *
 * Входные параметры:
 *   array - указатель на область памяти, в которой хранятся элементы массива.
 *   length - количество элементов в этом массиве.
 *
 * Выходные параметры:
 *   err - код выхода:
 *     0 - успешное выполнение функции;
 *     1 - память по указателю array не захвачена;
 *     2 - массив не содержит элементов.
 *
 * Возвращаемое значение:
 *   Искомая сумма.
 *
 * Алгоритм:
 *   Линейно сканируются элементы массива. В предварительно инициализированную
 *   нулём сумму добавляется значение текущего элемента.
 *
 * Разработчик: Васин Д.Ю.
 * Версия: 1.0
 * Дата: 03.03.21
 */
int
array_sum (int* array, int length, int* err)
{
  int sum = 0, i;

  /* Проверка на ошибки. */

  if (array == NULL)
    {
      *err = 1;
      return sum;
    }

  if (length <= 0)
    {
      *err = 2;
      return sum;
    }

  /* Реализация алгоритма. */
  for (i = 0; i < length; i++)
    sum += array[i];

  *err = 0;
  return sum;
}

/*
 * Функция нахождения элементов массива, наиболее близкого и наиболее далёкого
 * от суммы элементов этого массива.
 *
 * Входные параметры:
 *   array - указатель на область памяти, в которой хранятся элементы массива.
 *   length - количество элементов в этом массиве.
 *
 * Выходные параметры:
 *   closest_val - значение элемента, наиболее близкого по значению к сумме
 *                 элементов данного массива.
 *   closest_idx - индекс этого элемента.
 *   furthest_val - значение элемента, наиболее далёкого по значению от суммы
 *                  элементов данного массива.
 *   furthest_idx - индекс этого элемента.
 *
 * Возвращаемое значение - код выхода:
 *   0 - успешное выполнение функции;
 *   1 - память по указателю array не захвачена;
 *   2 - массив не содержит элементов.
 *
 * Алгоритм:
 *   Для каждого элемента массива вычисляется его расстояние от суммы элементов
 *   этого массива. Элемент с наибольшим расстоянием - наиболее далёкий, с
 *   наименьшим - наиболее близкий.
 */
int
solve (int* array, int length, int* closest_val, int* closest_idx,
       int* furthest_val, int* furthest_idx)
{
  int i, dist, dist_f, dist_c;
  int err, sum = array_sum (array, length, &err);

  /* Данная функция использует те же коды ошибок, что и array_sum(). */
  if (err)
    return err;

  /* Реализация алгоритма. */
  for (i = 0; i < length; i++)
    {
      /* Расстояние между текущим элементом и суммой элементов массива. */
      dist = abs (array[i] - sum);

      /* Инициализация переменных на первой итерации. */
      if (!i)
        {
          *closest_val = *furthest_val = array[i];
          *closest_idx = *furthest_idx = i;
          dist_f = dist_c = dist;
        }

      /* Сравнение расстояний, как описано в алгоритме. */

      if (dist < dist_c)
        {
          *closest_val = array[i];
          *closest_idx = i;
          dist_c = dist;
        }

      if (dist > dist_f)
        {
          *furthest_val = array[i];
          *furthest_idx = i;
          dist_f = dist;
        }
    }

  return 0;
}

int
main ()
{
  int length, *array = NULL;
  int i, err, closest_val, closest_idx, furthest_val, furthest_idx;

  /* Правильный вывод кириллицы. */
  fix_locale ();

  do
    {
      cout << "Длина массива (не более 100 элементов): ";
      cin >> length;
    }
  while (length <= 0 || length > 100);

  /* Захват памяти под массив. */
  array = new int[length];

  if (array == NULL)
    {
      cout << "Ошибка захвата памяти" << endl;
      getch ();
      return 1;
    }

  /* Инициализация генератора случайных чисел. */
  randomize ();

  cout << endl << "Заполненный массив:" << endl;

  /* Заполнение и вывод массива. */
  for (i = 0; i < length; i++)
    {
      array[i] = random (101) - 50;

      if (i && !(i % 10))
        cout << endl;
      else if (i)
        cout << " ";

      cout << setw (3) << array[i];
    }

  /* Решение задачи оформлено отдельной функцией. */
  err = solve (array, length, &closest_val, &closest_idx,
               &furthest_val, &furthest_idx);

  /* Вывод соответствующего сообщения в зависимости от кода выхода. */
  switch (err)
    {
    case 0:
      cout << endl << endl << "Значение наиболее близкого элемента: " << closest_val;
      cout << endl << "Его индекс: " << closest_idx;

      cout << endl << endl << "Значение наиболее далёкого элемента: " << furthest_val;
      cout << endl << "Его индекс: " << furthest_idx;

      break;
    case 1:
      cout << endl << endl << "Ошибка захвата памяти" << endl;
      break;
    case 2:
      cout << endl << endl << "Массив пуст" << endl;
      break;
    }

  /* Освобождение ранее захваченной памяти. */
  if (array != NULL)
    {
      delete[] array;
      array = NULL;
    }

  getch ();
  return err;
}
