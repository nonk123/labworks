/*
 * №3. Скалярное произведение двух N-мерных векторов.
 *
 * Необходимо написать функцию, которая считает скалярное произведение двух
 * N-мерных векторов.
 */

#include "common.hpp"

/*
 * Функция вычисления скалярного произведения двух векторов.
 *
 * Входные параметры:
 *   A - указатель на область памяти, в которой расположены элементы первого
 *       вектора.
 *   B - указатель на область памяти, в которой расположены элементы второго
 *       вектора.
 *   N - размерность этих векторов.
 *
 * Выходные параметры:
 *   err - код выхода:
 *     0 - успешное выполнение функции;
 *     1 - по указателю A не захвачена память;
 *     2 - по указателю B не захвачена память;
 *     3 - векторы не содержат элементов.
 *
 * Возвращаемое значение:
 *   Искомое скалярное произведение.
 *
 * Алгоритм:
 *   Используется математическое определение скалярного произведения N-мерных
 *   векторов: это сумма произведений соответствующих координат векторов.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 25.03.21
 */
int
dot_product (int* A, int* B, int N, int* err)
{
  int i, dot = 0;

  if (A == NULL)
    {
      *err = 1;
      return dot;
    }

  if (B == NULL)
    {
      *err = 2;
      return dot;
    }

  if (N <= 0)
    {
      *err = 3;
      return dot;
    }

  for (i = 0; i < N; i++)
    dot += A[i] * B[i];

  *err = 0;
  return dot;
}

int
main ()
{
  int *A = NULL, *B = NULL, N, i, dot, err;

  /* Правильный вывод кириллицы. */
  fix_locale ();

  do
    {
      cout << "Размерность векторов (не более 20): "; cin >> N;
    }
  while (N <= 0 || N > 20);

  A = new int[N];

  if (A == NULL)
    {
      cout << "Ошибка захвата памяти под вектор A" << endl;
      getch ();
      return 1;
    }

  B = new int[N];

  if (B == NULL)
    {
      /* Освобождение уже захваченной памяти. */
      if (A != NULL)
        {
          delete[] A;
          A = NULL;
        }

      cout << "Ошибка захвата памяти под вектор B" << endl;
      getch ();
      return 1;
    }

  /* Инициализация генератора случайных чисел. */
  randomize ();

  cout << endl << "  A       B  " << endl;

  /* Заполнение и "красивый" вывод векторов на экран. */
  for (i = 0; i < N; i++)
    {
      /* Генерация случайных чисел в диапазоне [-10; 10]. */
      A[i] = random (21) - 10;
      B[i] = random (21) - 10;

      cout << "|" << setw (3) << A[i] << "|   |" << setw(3) << B[i] << "|" << endl;
    }

  /* Нахождение скалярного произведения. */
  dot = dot_product (A, B, N, &err);

  /* Вывод сообщения об ошибке. */
  switch (err)
    {
    case 0:
      cout << endl << "A . B = " << dot << endl;
      break;
    case 1:
      cout << endl << "Ошибка захвата памяти под вектор A" << endl;
      break;
    case 2:
      cout << endl << "Ошибка захвата памяти под вектор B" << endl;
      break;
    case 3:
      cout << endl << "Векторы не содержат элементов" << endl;
      break;
    }

  /* Освобождение ранее захваченной памяти. */

  if (A != NULL)
    {
      delete[] A;
      A = NULL;
    }

  if (B != NULL)
    {
      delete[] B;
      B = NULL;
    }

  getch ();
  return err;
}
