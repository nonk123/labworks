/*
 * №4. Вставка и удаление элементов массива.
 *
 * Необходимо реализовать следующие алгоритмы:
 *   1. Вставка элементов массива B в начало массива A.
 *   2. Вставка элементов массива B в конец массива A.
 *   3. Вставка элементов массива B в массив A после произвольного индекса.
 *   4. Удаление всех элементов массива B из массива A.
 */

#include "common.hpp"

/*
 * Функция вставки элементов одного массива в начало другого.
 *
 * Входные параметры:
 *   A - массив, в который будет произведена вставка элементов массива B;
 *   B_len - количество элементов в массиве B.
 *
 * Выходные параметры:
 *   A_len - новое количество элементов в массиве A.
 *
 * Возвращаемое значение - код выхода:
 *   0 - успешное выполнение функции;
 *   1 - по одному из указателей не захвачена память.
 *
 * Алгоритм:
 *   1. Элементы массива A сдвигаются вперёд на B_len ячеек.
 *   2. В начало массива A записываются все элементы массива B.
 *
 * Примечание:
 *   Под массив A должно быть выделено достаточное количество памяти, чтобы
 *   туда также поместился массив B.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 25.03.21
 */
int
prepend (int* A, int* A_len, int* B, int B_len)
{
  int i;

  if (A == NULL || B == NULL || A_len == NULL)
    return 1;

  /* Сдвиг элементов массива A вперёд. */
  for (i = *A_len - 1; i >= 0; i--)
    A[B_len + i] = A[i];

  /* Запись элементов массива B в начало массива A. */
  for (i = 0; i < B_len; i++)
    A[i] = B[i];

  /* Длина массива A увеличилась после выполнения функции. */
  *A_len += B_len;

  return 0;
}

/*
 * Функция вставки элементов одного массива в конец другого.
 *
 * Входные параметры:
 *   A - массив, в который будет произведена вставка элементов массива B;
 *   B_len - количество элементов в массиве B.
 *
 * Выходные параметры:
 *   A_len - новое количество элементов в массиве A.
 *
 * Возвращаемое значение - код выхода:
 *   0 - успешное выполнение функции;
 *   1 - по одному из указателей не захвачена память.
 *
 * Алгоритм:
 *   Элементы массива B последовательно записываются в конец массива A.
 *
 * Примечание:
 *   Под массив A должно быть выделено достаточное количество памяти, чтобы
 *   туда также поместился массив B.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 30.03.21
 */
int
append (int* A, int* A_len, int* B, int B_len)
{
  int i;

  if (A == NULL || B == NULL || A_len == NULL)
    return 1;

  /* Запись элементов массива B в конец массива A. */
  for (i = 0; i < B_len; i++)
    A[*A_len + i] = B[i];

  /* Длина массива A увеличилась после выполнения функции. */
  *A_len += B_len;

  return 0;
}

/*
 * Функция вставки элементов одного массива в другой после некоторого элемента.
 *
 * Входные параметры:
 *   A - массив, в который будет произведена вставка элементов массива B;
 *   B_len - количество элементов в массиве B;
 *   idx - индекс элемента, после которого будет производиться вставка.
 *
 * Выходные параметры:
 *   A_len - новое количество элементов в массиве A.
 *
 * Возвращаемое значение - код выхода:
 *   0 - успешное выполнение функции;
 *   1 - по одному из указателей не захвачена память;
 *   2 - idx находится за пределами массива.
 *
 * Алгоритм:
 *   1. Элементы массива A, начиная с индекса idx, сдвигаются на B_len ячеек
 *      вперёд.
 *   2. В освободившееся место записываются элементы массива B.
 *
 * Примечание:
 *   Под массив A должно быть выделено достаточное количество памяти, чтобы
 *   туда также поместился массив B.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 30.03.21
 */
int
insert (int* A, int* A_len, int* B, int B_len, int idx)
{
  int i;

  if (A == NULL || A_len == NULL || B == NULL)
    return 1;

  if (idx < 0 || idx >= *A_len)
    return 2;

  /* Сдвиг элементов массива A. */
  for (i = *A_len - 1; i >= idx; i--)
    A[B_len + i] = A[i];

  /* Запись элементов массива B. */
  for (i = 0; i < B_len; i++)
    A[idx + i] = B[i];

  *A_len += B_len;

  return 0;
}

/*
 * Функция удаления всех элементов одного массива из другого.
 *
 * Входные параметры:
 *   A - массив, из которого будут удалены все элементы массива B;
 *   B_len - длина массива B.
 *
 * Выходные параметры:
 *   A_len - новое количество элементов в массиве A.
 *
 * Возвращаемое значение - код выхода:
 *   0 - успешное выполнение функции;
 *   1 - по одному из указателей не захвачена память.
 *
 * Алгоритм:
 *   Линейно сканируются элементы массива A. Если текущий элемент находится в
 *   массиве B, то он удаляется посредством сдвига последующих элементов
 *   массива A назад на одну ячейку. В этом случае длина массива A уменьшается
 *   на единицу.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 31.03.21
 */
int
remove_all (int* A, int* A_len, int* B, int B_len)
{
  int i, j, k;

  if (A == NULL || B == NULL || A_len == NULL)
    return 1;

  /* Реализация алгоритма. */
  for (i = 0; i < *A_len; )
    {
      k = -1;

      /* Поиск текущего элемента в массиве B. */
      for (j = 0; j < B_len; j++)
        {
          if (A[i] == B[j])
            {
              /* Элемент найден. Сжимаем массив. */
              (*A_len)--;

              /* Сдвиг назад. */
              for (k = i; k < *A_len; k++)
                A[k] = A[k + 1];

              /* Нет смысла продолжать поиск. */
              break;
            }
        }

      /* Переходим к следующему элементу, если поиск не удался. */
      if (k == -1)
        i++;
    }

  return 0;
}

/*
 * Функция вывода массива на экран.
 *
 * Входные параметры:
 *   A - указатель на область памяти, в которой находится выводимый массив;
 *   len - количество элементов в этом массиве.
 *
 * Функция не производит вывод массива, если по указателю A не захвачена память
 * или заданный массив не содержит элементов.
 *
 * Алгоритм:
 *   Элементы массива линейно сканируются и выводятся на экран. После каждого
 *   десятого элемента выводится перенос строки.
 *
 * Разработчик: Судаков С.А.
 * Версия: 1.0
 * Дата: 28.03.21
 */
void
print_array (int* A, int len)
{
  int i;

  if (A == NULL)
    return;

  for (i = 0; i < len; i++)
    {
      /* Вывод переноса строки. */
      if (i && !(i % 10))
        cout << endl;

      cout << setw (3) << A[i] << " ";
    }
}

int
main ()
{
  int *A = NULL, *B = NULL, A_len, B_len, i, idx;

  /* Правильный вывод кириллицы. */
  fix_locale ();

  do
    {
      cout << "Длина массива A (до 20): ";
      cin >> A_len;
    }
  while (A_len <= 0 || A_len > 20);

  do
    {
      cout << "Длина массива B (до 10): ";
      cin >> B_len;
    }
  while (B_len <= 0 || B_len > 10);

  /* Захват памяти под массив A. */
  A = new int[A_len + 3 * B_len];

  if (A == NULL)
    {
      cout << "Ошибка захвата памяти под массив A" << endl;
      getch ();
      return 1;
    }

  /* Захват памяти под массив B. */
  B = new int[B_len];

  if (B == NULL)
    {
      /* Освобождение ранее захваченной памяти в случае ошибки. */
      if (A != NULL)
        {
          delete[] A;
          A = NULL;
        }

      cout << "Ошибка захвата памяти под массив B" << endl;
      getch ();
      return 1;
    }

  randomize ();

  /* Заполнение и вывод массивов. */

  for (i = 0; i < A_len; i++)
    /* Генерация случайных чисел в диапазоне [-10; 10]. */
    A[i] = random (21) - 10;

  for (i = 0; i < B_len; i++)
    B[i] = random (21) - 10;

  cout << endl << "Массив A:" << endl;
  print_array (A, A_len);

  cout << endl << endl << "Массив B:" << endl;
  print_array (B, B_len);

  switch (prepend (A, &A_len, B, B_len))
    {
    case 0:
      cout << endl << endl << "Массив A после вставки туда элементов массива B в начало:" << endl;
      print_array (A, A_len);
      break;
    case 1:
      cout << endl << "Ошибка памяти" << endl;
      break;
    }

  switch (append (A, &A_len, B, B_len))
    {
    case 0:
      cout << endl << endl << "Массив A после вставки туда элементов массива B в конец:" << endl;
      print_array (A, A_len);
      break;
    case 1:
      cout << endl << "Ошибка памяти" << endl;
      break;
    }

  /* Выбор случайного индекса для вставки после него. */
  idx = random (A_len);

  switch (insert (A, &A_len, B, B_len, idx))
    {
    case 0:
      cout << endl << endl << "Массив A после вставки туда элементов массива B после индекса "
           << idx << ":" << endl;
      print_array (A, A_len);
      break;
    case 1:
      cout << endl << "Ошибка памяти" << endl;
      break;
    case 2:
      cout << endl << "Индекс находится за пределами массива" << endl;
      break;
    }

  switch (remove_all (A, &A_len, B, B_len))
    {
    case 0:
      cout << endl << endl << "Массив A после удаления из него всех элементов массива B:" << endl;
      print_array (A, A_len);
      break;
    case 1:
      cout << endl << "Ошибка памяти" << endl;
      break;
    }

  /* Освобождение ранее захваченной памяти. */

  if (A != NULL)
    {
      delete[] A;
      A = NULL;
    }

  if (B != NULL)
    {
      delete[] B;
      B = NULL;
    }

  getch ();
  return 0;
}
